<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>getsockopt (ZMQ::Socket)</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
</head>
<body class="standalone-code">
  <pre>/*
 * call-seq:
 *   socket.getsockopt(option)
 *
 * Retrieves the value of the specified 0MQ socket option.
 *
 * The following options can be retrievesd with the getsockopt() function:
 *
 * == ZMQ::RCVMORE: More message parts to follow
 * The ZMQ::RCVMORE option shall return a boolean value indicating if the
 * multi-part message currently being read from the specified socket has more
 * message parts to follow. If there are no message parts to follow or if the
 * message currently being read is not a multi-part message a value of false
 * shall be returned. Otherwise, a value of true shall be returned.
 *
 * Refer to send() and recv() for a detailed description of sending/receiving
 * multi-part messages.
 *
 * [Option value type] Boolean
 * [Option value unit] N/A
 * [Default value] N/A
 * [Applicable socket types] all
 *
 * == ZMQ::HWM: Retrieve high water mark
 * The ZMQ::HWM option shall retrieve the high water mark for the specified
 * _socket_. The high water mark is a hard limit on the maximum number of
 * outstanding messages 0MQ shall queue in memory for any single peer that the
 * specified _socket_ is communicating with.
 *
 * If this limit has been reached the socket shall enter an exceptional state
 * and depending on the socket type, 0MQ shall take appropriate action such as
 * blocking or dropping sent messages. Refer to the individual socket
 * descriptions in ZMQ::Socket for details on the exact action taken for each
 * socket type.
 *
 * The default ZMQ::HWM value of zero means &quot;no limit&quot;.
 *
 * [Option value type] Integer
 * [Option value unit] messages
 * [Default value] 0
 * [Applicable socket types] all
 *
 * == ZMQ::SWAP: Retrieve disk offload size
 * The ZMQ::SWAP option shall retrieve the disk offload (swap) size for the
 * specified _socket_. A socket which has ZMQ::SWAP set to a non-zero value may
 * exceed it’s high water mark; in this case outstanding messages shall be
 * offloaded to storage on disk rather than held in memory.
 *
 * The value of ZMQ::SWAP defines the maximum size of the swap space in bytes.
 *
 * [Option value type] Integer
 * [Option value unit] bytes
 * [Default value] 0
 * [Applicable socket types] all
 *
 * == ZMQ::AFFINITY: Retrieve I/O thread affinity
 * The ZMQ::AFFINITY option shall retrieve the I/O thread affinity for newly
 * created connections on the specified _socket_.
 *
 * Affinity determines which threads from the 0MQ I/O thread pool associated
 * with the socket’s _context_ shall handle newly created connections. A value of
 * zero specifies no affinity, meaning that work shall be distributed fairly
 * among all 0MQ I/O threads in the thread pool. For non-zero values, the lowest
 * bit corresponds to thread 1, second lowest bit to thread 2 and so on. For
 * example, a value of 3 specifies that subsequent connections on _socket_ shall
 * be handled exclusively by I/O threads 1 and 2.
 *
 * See also ZMQ::Context#new for details on allocating the number of
 * I/O threads for a specific _context_.
 *
 * [Option value type] Integer
 * [Option value unit] N/A (bitmap)
 * [Default value] 0
 * [Applicable socket types] all
 *
 * == ZMQ::IDENTITY: Retrieve socket identity
 * The ZMQ::IDENTITY option shall retrieve the identity of the specified _socket_.
 * Socket identity determines if existing 0MQ infastructure (&lt;em&gt;message queues&lt;/em&gt;,
 * &lt;em&gt;forwarding devices&lt;/em&gt;) shall be identified with a specific application and
 * persist across multiple runs of the application.
 *
 * If the socket has no identity, each run of an application is completely
 * separate from other runs. However, with identity set the socket shall re-use
 * any existing 0MQ infrastructure configured by the previous run(s). Thus the
 * application may receive messages that were sent in the meantime, &lt;em&gt;message
 * queue&lt;/em&gt; limits shall be shared with previous run(s) and so on.
 *
 * Identity can be at least one byte and at most 255 bytes long. Identities
 * starting with binary zero are reserved for use by 0MQ infrastructure.
 *
 * [Option value type] String
 * [Option value unit] N/A
 * [Default value] nil
 * [Applicable socket types] all
 *
 * == ZMQ::RATE: Retrieve multicast data rate
 *
 * The ZMQ::Rate option shall retrieve the maximum send or receive data
 * rate for multicast transports using the specified _socket_.
 * 
 * [Option value type] Integer
 * [Option value unit] kilobits per second
 * [Default value] 100
 * [Applicable socket types] all, when using multicast transports
 *
 * == ZMQ::RECOVERY_IVL: Get multicast recovery interval
 *
 * The ZMQ::RECOVERY_IVL option shall retrieve the recovery interval for
 * multicast transports using the specified _socket_. The recovery interval
 * determines the maximum time in seconds that a receiver can be absent from a
 * multicast group before unrecoverable data loss will occur.
 *
 * [Option value type] Integer
 * [Option value unit] seconds
 * [Default value] 10
 * [Applicable socket types] all, when using multicast transports
 *
 * == ZMQ::MCAST_LOOP: Control multicast loopback
 * The ZMQ::MCAST_LOOP option controls whether data sent via multicast transports
 * can also be received by the sending host via loopback. A value of zero
 * indicates that the loopback functionality is disabled, while the default
 * value of 1 indicates that the loopback functionality is enabled. Leaving
 * multicast loopback enabled when it is not required can have a negative impact
 * on performance. Where possible, disable ZMQ::MCAST_LOOP in production
 * environments.
 *
 * [Option value type] Boolean
 * [Option value unit] N/A
 * [Default value] true
 * [Applicable socket types] all, when using multicast transports
 *
 * == ZMQ::SNDBUF: Retrieve kernel transmit buffer size
 * The ZMQ::SNDBUF option shall retrieve the underlying kernel transmit buffer
 * size for the specified _socket_. A value of zero means that the OS default is
 * in effect. For details refer to your operating system documentation for the
 * SO_SNDBUF socket option.
 * 
 * [Option value type] Integer
 * [Option value unit] bytes
 * [Default value] 0
 * [Applicable socket types] all
 *
 * == ZMQ::RCVBUF: Retrieve kernel receive buffer size
 * The ZMQ::RCVBUF option shall retrieve the underlying kernel receive buffer
 * size for the specified _socket_. A value of zero means that the OS default is
 * in effect. For details refer to your operating system documentation for the
 * SO_RCVBUF socket option.
 * 
 * [Option value type] Integer
 * [Option value unit] bytes
 * [Default value] 0
 * [Applicable socket types] all
 *
 */
static VALUE socket_getsockopt (VALUE self_, VALUE option_)
{
    int rc = 0;
    VALUE retval;
    void * s;
    
    Data_Get_Struct (self_, void, s);
    Check_Socket (s);
  
    switch (NUM2INT (option_)) {
    case ZMQ_RCVMORE:
    case ZMQ_HWM:
    case ZMQ_SWAP:
    case ZMQ_AFFINITY:
    case ZMQ_RATE:
    case ZMQ_RECOVERY_IVL:
    case ZMQ_MCAST_LOOP:
    case ZMQ_SNDBUF:
    case ZMQ_RCVBUF:
        {
            int64_t optval;
            size_t optvalsize = sizeof(optval);

            rc = zmq_getsockopt (s, NUM2INT (option_), (void *)&amp;optval,
                                 &amp;optvalsize);

            if (rc != 0) {
              rb_raise (rb_eRuntimeError, &quot;%s&quot;, zmq_strerror (zmq_errno ()));
              return Qnil;
            }

            if (NUM2INT (option_) == ZMQ_RCVMORE)
                retval = optval ? Qtrue : Qfalse;
            else
                retval = INT2NUM (optval);
        }
        break;
    case ZMQ_IDENTITY:
        {
            char identity[255];
            size_t optvalsize = sizeof (identity);

            rc = zmq_getsockopt (s, NUM2INT (option_), (void *)identity,
                                 &amp;optvalsize);

            if (rc != 0) {
              rb_raise (rb_eRuntimeError, &quot;%s&quot;, zmq_strerror (zmq_errno ()));
              return Qnil;
            }

            if (optvalsize &gt; sizeof (identity))
                optvalsize = sizeof (identity);

            retval = rb_str_new (identity, optvalsize);
        }
        break;
    default:
        rb_raise (rb_eRuntimeError, &quot;%s&quot;, zmq_strerror (EINVAL));
        return Qnil;
    }
  
    return retval;
}</pre>
</body>
</html>
